// Generated by CoffeeScript 1.6.3
var cli, executeTransaction, flattenHeaders, gavel, html, http, https, indent, os, packageConfig, prettify, url;

flattenHeaders = require('./flatten-headers');

gavel = require('gavel');

http = require('http');

https = require('https');

html = require('html');

url = require('url');

os = require('os');

packageConfig = require('./../package.json');

cli = require('cli');

indent = '  ';

String.prototype.trunc = function(n) {
  if (this.length > n) {
    return this.substr(0, n - 1) + '...';
  } else {
    return this;
  }
};

String.prototype.startsWith = function(str) {
  return this.slice(0, str.length) === str;
};

prettify = function(transaction) {
  var e, parsed, type;
  type = (transaction != null ? transaction.headers['Content-Type'] : void 0) || (transaction != null ? transaction.headers['content-type'] : void 0);
  switch (type) {
    case 'application/json':
      try {
        parsed = JSON.parse(transaction.body);
      } catch (_error) {
        e = _error;
        cli.error("Error parsing body as json: " + transaction.body);
        parsed = transaction.body;
      }
      transaction.body = parsed;
      break;
    case 'text/html':
      transaction.body = html.prettyPrint(transaction.body, {
        indent_size: 2
      });
  }
  return transaction;
};

executeTransaction = function(transaction, callback) {
  var buffer, configuration, description, flatHeaders, handleRequest, header, options, origin, parsedUrl, req, request, response, system, value, _ref, _ref1;
  configuration = transaction['configuration'];
  origin = transaction['origin'];
  request = transaction['request'];
  response = transaction['response'];
  parsedUrl = url.parse(configuration['server']);
  flatHeaders = flattenHeaders(request['headers']);
  if (flatHeaders['User-Agent'] === void 0) {
    system = os.type() + ' ' + os.release() + '; ' + os.arch();
    flatHeaders['User-Agent'] = "Dredd/" + packageConfig['version'] + " (" + system + ")";
  }
  if (((_ref = configuration.request) != null ? _ref.headers : void 0) != null) {
    _ref1 = configuration['request']['headers'];
    for (header in _ref1) {
      value = _ref1[header];
      flatHeaders[header] = value;
    }
  }
  options = {
    host: parsedUrl['hostname'],
    port: parsedUrl['port'],
    path: request['uri'],
    method: request['method'],
    headers: flatHeaders
  };
  description = origin['resourceGroupName'] + ' > ' + origin['resourceName'] + ' > ' + origin['actionName'] + ' > ' + origin['exampleName'] + ':\n' + indent + options['method'] + ' ' + options['path'] + ' ' + JSON.stringify(request['body']).trunc(20);
  if (configuration.options['dry-run']) {
    cli.info("Dry run, skipping...");
    return callback();
  } else {
    buffer = "";
    handleRequest = function(res) {
      res.on('data', function(chunk) {
        return buffer = buffer + chunk;
      });
      req.on('error', function(error) {
        return callback(error);
      });
      return res.on('end', function() {
        var expected, real;
        real = {
          headers: res.headers,
          body: buffer,
          status: res.statusCode
        };
        expected = {
          headers: flattenHeaders(response['headers']),
          body: response['body'],
          bodySchema: response['schema'],
          statusCode: response['status']
        };
        return gavel.isValid(real, expected, 'response', function(error, isValid) {
          var test;
          if (error) {
            return callback(error);
          }
          if (isValid) {
            test = {
              status: "pass",
              title: options['method'] + ' ' + options['path'],
              message: description
            };
            configuration.reporter.addTest(test, function(error) {
              if (error) {
                return callback(error);
              }
            });
            return callback();
          } else {
            return gavel.validate(real, expected, 'response', function(error, result) {
              var data, entity, entityResult, message, _i, _len, _ref2;
              if (error) {
                return callback(error);
              }
              message = '';
              for (entity in result) {
                data = result[entity];
                _ref2 = data['results'];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  entityResult = _ref2[_i];
                  message += entity + ": " + entityResult['message'] + "\n";
                }
              }
              test = {
                status: "fail",
                title: options['method'] + ' ' + options['path'],
                message: message,
                actual: prettify(real),
                expected: prettify(expected),
                request: options
              };
              configuration.reporter.addTest(test, function(error) {
                if (error) {
                  return callback(error);
                }
              });
              return callback();
            });
          }
        });
      });
    };
    if (configuration.server.startsWith('https')) {
      req = https.request(options, handleRequest);
    } else {
      req = http.request(options, handleRequest);
    }
    if (request['body'] !== '') {
      req.write(request['body']);
    }
    return req.end();
  }
};

module.exports = executeTransaction;
