// Generated by CoffeeScript 1.6.3
var cli, executeTransaction, flattenHeaders, gavel, html, http, https, indent, os, packageConfig, prettify, url;

flattenHeaders = require('./flatten-headers');

gavel = require('gavel');

http = require('http');

https = require('https');

html = require('html');

url = require('url');

os = require('os');

packageConfig = require('./../package.json');

cli = require('cli');

indent = '  ';

String.prototype.trunc = function(n) {
  if (this.length > n) {
    return this.substr(0, n - 1) + '...';
  } else {
    return this;
  }
};

String.prototype.startsWith = function(str) {
  return this.slice(0, str.length) === str;
};

prettify = function(transaction) {
  var e, parsed, type;
  type = (transaction != null ? transaction.headers['Content-Type'] : void 0) || (transaction != null ? transaction.headers['content-type'] : void 0);
  switch (type) {
    case 'application/json':
      try {
        parsed = JSON.parse(transaction.body);
      } catch (_error) {
        e = _error;
        cli.error("Error parsing body as json: " + transaction.body);
        parsed = transaction.body;
      }
      transaction.body = parsed;
      break;
    case 'text/html':
      transaction.body = html.prettyPrint(transaction.body, {
        indent_size: 2
      });
  }
  return transaction;
};

executeTransaction = function(transaction, callback) {
  var buffer, caseInsensitiveMap, configuration, description, flatHeaders, handleRequest, header, key, options, origin, parsedUrl, req, request, response, startedAt, system, value, _ref, _ref1;
  configuration = transaction['configuration'];
  origin = transaction['origin'];
  request = transaction['request'];
  response = transaction['response'];
  parsedUrl = url.parse(configuration['server']);
  flatHeaders = flattenHeaders(request['headers']);
  startedAt = 0;
  if (flatHeaders['User-Agent'] === void 0) {
    system = os.type() + ' ' + os.release() + '; ' + os.arch();
    flatHeaders['User-Agent'] = "Dredd/" + packageConfig['version'] + " (" + system + ")";
  }
  caseInsensitiveMap = {};
  for (key in flatHeaders) {
    value = flatHeaders[key];
    caseInsensitiveMap[key.toLowerCase()] = key;
  }
  if (caseInsensitiveMap['content-length'] === void 0 && request['body'] !== '') {
    flatHeaders['Content-Length'] = request['body'].length;
  }
  if (((_ref = configuration.request) != null ? _ref.headers : void 0) != null) {
    _ref1 = configuration['request']['headers'];
    for (header in _ref1) {
      value = _ref1[header];
      flatHeaders[header] = value;
    }
  }
  options = {
    host: parsedUrl['hostname'],
    port: parsedUrl['port'],
    path: request['uri'],
    method: request['method'],
    headers: flatHeaders
  };
  description = origin['resourceGroupName'] + ' > ' + origin['resourceName'] + ' > ' + origin['actionName'] + ' > ' + origin['exampleName'] + ':\n' + indent + options['method'] + ' ' + options['path'] + ' ' + JSON.stringify(request['body']).trunc(20);
  if (configuration.options['dry-run']) {
    cli.info("Dry run, skipping...");
    return callback();
  } else {
    buffer = "";
    handleRequest = function(res) {
      res.on('data', function(chunk) {
        return buffer = buffer + chunk;
      });
      req.on('error', function(error) {
        return callback(error, req, res);
      });
      return res.on('end', function() {
        var expected, real, test;
        real = {
          headers: res.headers,
          body: buffer,
          status: res.statusCode
        };
        expected = {
          headers: flattenHeaders(response['headers']),
          body: response['body'],
          bodySchema: response['schema'],
          statusCode: response['status']
        };
        test = {
          status: "pass",
          title: options['method'] + ' ' + options['path'],
          message: description,
          request: options,
          realResponse: real,
          expectedResponse: expected,
          origin: transaction['origin'],
          duration: (new Date().getTime() / 1000) - startedAt
        };
        test['request']['body'] = transaction['request']['body'];
        return gavel.isValid(real, expected, 'response', function(error, isValid) {
          if (error) {
            return callback(error, req, res);
          }
          return gavel.validate(real, expected, 'response', function(error, result) {
            var data, entity, entityResult, message, _i, _len, _ref2;
            if (error) {
              return callback(error, req, res);
            }
            test['actual'] = prettify(real);
            test['expected'] = prettify(expected);
            test['result'] = result;
            if (!isValid) {
              message = message + '\n';
              for (entity in result) {
                data = result[entity];
                _ref2 = data['results'];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  entityResult = _ref2[_i];
                  message += entity + ": " + entityResult['message'] + "\n";
                }
              }
              test['message'] = message;
              test['status'] = 'fail';
            } else {
              test['status'] = 'pass';
            }
            return configuration.reporter.addTest(test, function(error) {
              if (error) {
                return callback(error, req, res);
              } else {
                return callback(void 0, req, res);
              }
            });
          });
        });
      });
    };
    startedAt = new Date().getTime() / 1000;
    if (configuration.server.startsWith('https')) {
      req = https.request(options, handleRequest);
    } else {
      req = http.request(options, handleRequest);
    }
    if (request['body'] !== '') {
      req.write(request['body']);
    }
    return req.end();
  }
};

module.exports = executeTransaction;
